//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace BauFahrplanMonitor.Trassenfinder.Generated
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TrassenfinderClient 
    {
        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings, true);
        private Newtonsoft.Json.JsonSerializerSettings _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public TrassenfinderClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            _httpClient = httpClient;
            Initialize();
        }

        private static Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Abfragen der verfügbaren Infrastrukturen
        /// </summary>
        /// <remarks>
        /// Gibt eine Zusammenfassung aller verfügbaren Infrastrukturen zurück.
        /// </remarks>
        /// <returns>Abfragen der Infrastrukturen erfolgreich</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Infrastruktur_summary>> Get_infrastrukturenAsync()
        {
            return Get_infrastrukturenAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfragen der verfügbaren Infrastrukturen
        /// </summary>
        /// <remarks>
        /// Gibt eine Zusammenfassung aller verfügbaren Infrastrukturen zurück.
        /// </remarks>
        /// <returns>Abfragen der Infrastrukturen erfolgreich</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Infrastruktur_summary>> Get_infrastrukturenAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v9/infrastrukturen"
                    urlBuilder_.Append("api/v9/infrastrukturen");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Infrastruktur_summary>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 304)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Die Daten haben sich seit der letzen Anfrage nicht ge\u00e4ndert und werden daher nicht erneut \u00fcbertragen", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Invalid_request_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Invalid_request_error>("\u00dcbermittelte Daten ung\u00fcltig", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Not_found_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Not_found_error>("Daten wurden aktualisiert/nicht gefunden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Timeout_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Timeout_error>("Anfrage konnte nicht bearbeitet werden (Timeout)", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Too_many_requests>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Too_many_requests>("Zu viele Anfragen gesendet", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Unexpected_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Unexpected_error>("Ein interner Serverfehler ist aufgetreten", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Abfragen einer Infrastruktur
        /// </summary>
        /// <remarks>
        /// Gibt die Betriebsstellen, Streckensegmente u.v.m. einer Infrastruktur zurück. Die zu übertragende Datenmenge ist im Normalfall nicht unerheblich.
        /// </remarks>
        /// <param name="infrastrukturId">ID der Infrastruktur</param>
        /// <returns>Abfragen der Infrastruktur erfolgreich</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Infrastruktur> Get_infrastrukturAsync(long infrastrukturId)
        {
            return Get_infrastrukturAsync(infrastrukturId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfragen einer Infrastruktur
        /// </summary>
        /// <remarks>
        /// Gibt die Betriebsstellen, Streckensegmente u.v.m. einer Infrastruktur zurück. Die zu übertragende Datenmenge ist im Normalfall nicht unerheblich.
        /// </remarks>
        /// <param name="infrastrukturId">ID der Infrastruktur</param>
        /// <returns>Abfragen der Infrastruktur erfolgreich</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Infrastruktur> Get_infrastrukturAsync(long infrastrukturId, System.Threading.CancellationToken cancellationToken)
        {
            if (infrastrukturId == null)
                throw new System.ArgumentNullException("infrastrukturId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v9/infrastrukturen/{infrastrukturId}"
                    urlBuilder_.Append("api/v9/infrastrukturen/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(infrastrukturId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Infrastruktur>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 304)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Die Daten haben sich seit der letzen Anfrage nicht ge\u00e4ndert und werden daher nicht erneut \u00fcbertragen", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Invalid_request_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Invalid_request_error>("\u00dcbermittelte Daten ung\u00fcltig", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Not_found_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Not_found_error>("Daten wurden aktualisiert/nicht gefunden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Timeout_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Timeout_error>("Anfrage konnte nicht bearbeitet werden (Timeout)", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Too_many_requests>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Too_many_requests>("Zu viele Anfragen gesendet", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Unexpected_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Unexpected_error>("Ein interner Serverfehler ist aufgetreten", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Durchführung einer Routensuche
        /// </summary>
        /// <remarks>
        /// Startet eine Routensuche inklusive Fahrzeit- und Trassenpreis-Berechnung. Falls die Trassenpreis-Berechnung fehlschlägt, wird das Ergebnis ohne Trassenpreis zurückgegeben.
        /// </remarks>
        /// <param name="body">Die zu bearbeitende Routenanfrage</param>
        /// <returns>Routensuche erfolgreich durchgeführt</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Routensuche_response> SucheAsync(Routensuche_request body)
        {
            return SucheAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Durchführung einer Routensuche
        /// </summary>
        /// <remarks>
        /// Startet eine Routensuche inklusive Fahrzeit- und Trassenpreis-Berechnung. Falls die Trassenpreis-Berechnung fehlschlägt, wird das Ergebnis ohne Trassenpreis zurückgegeben.
        /// </remarks>
        /// <param name="body">Die zu bearbeitende Routenanfrage</param>
        /// <returns>Routensuche erfolgreich durchgeführt</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Routensuche_response> SucheAsync(Routensuche_request body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v9/routen/suche"
                    urlBuilder_.Append("api/v9/routen/suche");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Routensuche_response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Invalid_request_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Invalid_request_error>("\u00dcbermittelte Daten ung\u00fcltig", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Not_found_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Not_found_error>("Daten wurden aktualisiert/nicht gefunden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Timeout_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Timeout_error>("Anfrage konnte nicht bearbeitet werden (Timeout)", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 415)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Ung\u00fcltiges Anfrageformat", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Too_many_requests>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Too_many_requests>("Zu viele Anfragen gesendet", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Unexpected_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Unexpected_error>("Ein interner Serverfehler ist aufgetreten", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Abfragen eines Routenergebnisses
        /// </summary>
        /// <remarks>
        /// Diese Anfrage liefert das Ergebnis einer zuvor durchgeführten Routensuche zurück.
        /// </remarks>
        /// <param name="routenId">ID der Route</param>
        /// <returns>Abfragen der Route erfolgreich</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Routensuche_response> Get_routeAsync(string routenId)
        {
            return Get_routeAsync(routenId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfragen eines Routenergebnisses
        /// </summary>
        /// <remarks>
        /// Diese Anfrage liefert das Ergebnis einer zuvor durchgeführten Routensuche zurück.
        /// </remarks>
        /// <param name="routenId">ID der Route</param>
        /// <returns>Abfragen der Route erfolgreich</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Routensuche_response> Get_routeAsync(string routenId, System.Threading.CancellationToken cancellationToken)
        {
            if (routenId == null)
                throw new System.ArgumentNullException("routenId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v9/routen/{routenId}"
                    urlBuilder_.Append("api/v9/routen/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(routenId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Routensuche_response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Invalid_request_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Invalid_request_error>("\u00dcbermittelte Daten ung\u00fcltig", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Not_found_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Not_found_error>("Daten wurden aktualisiert/nicht gefunden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Timeout_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Timeout_error>("Anfrage konnte nicht bearbeitet werden (Timeout)", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Too_many_requests>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Too_many_requests>("Zu viele Anfragen gesendet", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Unexpected_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Unexpected_error>("Ein interner Serverfehler ist aufgetreten", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// PDF-Export der Route
        /// </summary>
        /// <remarks>
        /// Exportiert die Route als PDF-Datei.
        /// </remarks>
        /// <param name="routenId">ID der Route</param>
        /// <param name="route">Routentyp zur Auswahl zwischen Optimierungsvarianten</param>
        /// <returns>Dateiexport erfolgreich durchgeführt</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> Get_pdfAsync(string routenId, Route2? route)
        {
            return Get_pdfAsync(routenId, route, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// PDF-Export der Route
        /// </summary>
        /// <remarks>
        /// Exportiert die Route als PDF-Datei.
        /// </remarks>
        /// <param name="routenId">ID der Route</param>
        /// <param name="route">Routentyp zur Auswahl zwischen Optimierungsvarianten</param>
        /// <returns>Dateiexport erfolgreich durchgeführt</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> Get_pdfAsync(string routenId, Route2? route, System.Threading.CancellationToken cancellationToken)
        {
            if (routenId == null)
                throw new System.ArgumentNullException("routenId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/pdf"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v9/routen/{routenId}/pdf"
                    urlBuilder_.Append("api/v9/routen/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(routenId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/pdf");
                    urlBuilder_.Append('?');
                    if (route != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("route")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(route, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Invalid_request_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Invalid_request_error>("\u00dcbermittelte Daten ung\u00fcltig", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Not_found_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Not_found_error>("Daten wurden aktualisiert/nicht gefunden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Timeout_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Timeout_error>("Anfrage konnte nicht bearbeitet werden (Timeout)", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Too_many_requests>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Too_many_requests>("Zu viele Anfragen gesendet", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Unexpected_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Unexpected_error>("Ein interner Serverfehler ist aufgetreten", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// PNG-Export der Route
        /// </summary>
        /// <remarks>
        /// Exportiert die Route als PNG-Datei.
        /// </remarks>
        /// <param name="routenId">ID der Route</param>
        /// <param name="route">Routentyp zur Auswahl zwischen Optimierungsvarianten</param>
        /// <returns>Dateiexport erfolgreich durchgeführt</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> Get_pngAsync(string routenId, Route3? route)
        {
            return Get_pngAsync(routenId, route, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// PNG-Export der Route
        /// </summary>
        /// <remarks>
        /// Exportiert die Route als PNG-Datei.
        /// </remarks>
        /// <param name="routenId">ID der Route</param>
        /// <param name="route">Routentyp zur Auswahl zwischen Optimierungsvarianten</param>
        /// <returns>Dateiexport erfolgreich durchgeführt</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> Get_pngAsync(string routenId, Route3? route, System.Threading.CancellationToken cancellationToken)
        {
            if (routenId == null)
                throw new System.ArgumentNullException("routenId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("image/png"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v9/routen/{routenId}/png"
                    urlBuilder_.Append("api/v9/routen/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(routenId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/png");
                    urlBuilder_.Append('?');
                    if (route != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("route")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(route, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Invalid_request_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Invalid_request_error>("\u00dcbermittelte Daten ung\u00fcltig", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Not_found_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Not_found_error>("Daten wurden aktualisiert/nicht gefunden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Timeout_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Timeout_error>("Anfrage konnte nicht bearbeitet werden (Timeout)", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Too_many_requests>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Too_many_requests>("Zu viele Anfragen gesendet", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Unexpected_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Unexpected_error>("Ein interner Serverfehler ist aufgetreten", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Durchführung einer Alternativroutensuche
        /// </summary>
        /// <remarks>
        /// Startet die Suche nach einer Alternative zum gegebenen Routenergebnis. Falls die Trassenpreis-Berechnung fehlschlägt, wird das Ergebnis ohne Trassenpreis zurückgegeben.
        /// </remarks>
        /// <returns>Routensuche erfolgreich durchgeführt</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Routensuche_response> Suche_alternativrouteAsync(string routenId)
        {
            return Suche_alternativrouteAsync(routenId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Durchführung einer Alternativroutensuche
        /// </summary>
        /// <remarks>
        /// Startet die Suche nach einer Alternative zum gegebenen Routenergebnis. Falls die Trassenpreis-Berechnung fehlschlägt, wird das Ergebnis ohne Trassenpreis zurückgegeben.
        /// </remarks>
        /// <returns>Routensuche erfolgreich durchgeführt</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Routensuche_response> Suche_alternativrouteAsync(string routenId, System.Threading.CancellationToken cancellationToken)
        {
            if (routenId == null)
                throw new System.ArgumentNullException("routenId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v9/routen/{routenId}/suche-alternativroute"
                    urlBuilder_.Append("api/v9/routen/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(routenId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/suche-alternativroute");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Routensuche_response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Invalid_request_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Invalid_request_error>("\u00dcbermittelte Daten ung\u00fcltig", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Not_found_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Not_found_error>("Daten wurden aktualisiert/nicht gefunden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Timeout_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Timeout_error>("Anfrage konnte nicht bearbeitet werden (Timeout)", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Too_many_requests>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Too_many_requests>("Zu viele Anfragen gesendet", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Unexpected_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Unexpected_error>("Ein interner Serverfehler ist aufgetreten", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Abfragen der Trassenfinder-Version
        /// </summary>
        /// <remarks>
        /// Gibt die aktuelle Version des Trassenfinders zurück.
        /// </remarks>
        /// <returns>Abfragen der Version erfolgreich</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Version> Get_versionAsync()
        {
            return Get_versionAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfragen der Trassenfinder-Version
        /// </summary>
        /// <remarks>
        /// Gibt die aktuelle Version des Trassenfinders zurück.
        /// </remarks>
        /// <returns>Abfragen der Version erfolgreich</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Version> Get_versionAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "api/v9/version"
                    urlBuilder_.Append("api/v9/version");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Version>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 304)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Die Daten haben sich seit der letzen Anfrage nicht ge\u00e4ndert und werden daher nicht erneut \u00fcbertragen", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Invalid_request_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Invalid_request_error>("\u00dcbermittelte Daten ung\u00fcltig", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Not_found_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Not_found_error>("Daten wurden aktualisiert/nicht gefunden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 408)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Timeout_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Timeout_error>("Anfrage konnte nicht bearbeitet werden (Timeout)", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Too_many_requests>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Too_many_requests>("Zu viele Anfragen gesendet", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Unexpected_error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Unexpected_error>("Ein interner Serverfehler ist aufgetreten", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field_ = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field_ != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field_, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    /// <summary>
    /// Repräsentiert eine Bemerkung in einem Routenpunkt
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Bemerkung
    {

        /// <summary>
        /// Der Typ der Bemerkung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bemerkung_typ", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Bemerkung_typ Bemerkung_typ { get; set; }

        /// <summary>
        /// Die Bemerkung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1000)]
        public string Text { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Betriebsstelle sind Bahnanlagen wie Bahnhöfe oder Haltestellen.
    /// <br/>Bsp.: Im Hauptbahnhof der Stadt Mainz können mehrere Bahnhofsteile ausgewählt werden, die jeweils einer Betriebsstelle entsprechen
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Betriebsstelle
    {

        [Newtonsoft.Json.JsonProperty("bahnhof", Required = Newtonsoft.Json.Required.Always)]
        public bool Bahnhof { get; set; }

        /// <summary>
        /// Die Betriebsstellentypen am Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("betriebsstellentypen", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(100)]
        public System.Collections.Generic.ICollection<Betriebsstellentypen> Betriebsstellentypen { get; set; } = new System.Collections.ObjectModel.Collection<Betriebsstellentypen>();

        /// <summary>
        /// DS100 (Ril 100) der Betriebsstelle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ds100", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(5, MinimumLength = 2)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z][A-Z0-9 ]{0,3}[A-Z0-9]$")]
        public string Ds100 { get; set; }

        /// <summary>
        /// Gibt an, ob die Betriebsstelle elektrifiziert ist
        /// </summary>
        [Newtonsoft.Json.JsonProperty("elektrifiziert", Required = Newtonsoft.Json.Required.Always)]
        public bool Elektrifiziert { get; set; }

        /// <summary>
        /// Die geographischen Koordinaten der Betriebsstelle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("geo_koordinaten", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Geo_koordinaten Geo_koordinaten { get; set; }

        /// <summary>
        /// Der Langname der Betriebsstelle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("langname", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength = 2)]
        public string Langname { get; set; }

        /// <summary>
        /// Der Primary Location Code der Betriebsstelle innerhalb Europas (eindeutige Betriebsstellen-Nr.)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary_location_code", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(7, MinimumLength = 7)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{2}[0-9]{5}$")]
        public string Primary_location_code { get; set; }

        [Newtonsoft.Json.JsonProperty("x", Required = Newtonsoft.Json.Required.Always)]
        public double X { get; set; }

        [Newtonsoft.Json.JsonProperty("y", Required = Newtonsoft.Json.Required.Always)]
        public double Y { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die Betriebsstelle und Streckennummer mit zugehöriger Fehleranalyse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Detail
    {

        /// <summary>
        /// DS100 (Ril 100) der Betriebsstelle, die der Zug auf der gegebenen Streckennummer nicht durchfahren konnte
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ds100", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(5, MinimumLength = 2)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z][A-Z0-9 ]{0,3}[A-Z0-9]$")]
        public string Ds100 { get; set; }

        /// <summary>
        /// Streckennummer auf der, der Zug die gegebene Betriebsstelle nicht durchfahren konnte
        /// </summary>
        [Newtonsoft.Json.JsonProperty("streckennummer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 9999)]
        public int Streckennummer { get; set; }

        /// <summary>
        /// Ursachen dafür, dass der Zug die gegebene Betriebsstelle auf der gegebenen Streckennummer nicht durchfahren konnte
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ursachen", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Ursachen Ursachen { get; set; } = new Ursachen();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Repräsentiert ein Objekt, das alle Energieverbrauchswerte zu einem Routenpunkt enthält
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Energieverbrauch_info
    {

        /// <summary>
        /// Gesamtenergieverbrauch Kilowattstunden bis zum nächsten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("energieverbrauch_gesamt_kwh", Required = Newtonsoft.Json.Required.Always)]
        public int Energieverbrauch_gesamt_kwh { get; set; }

        /// <summary>
        /// Energieverbrauch der Hilfsbetriebe in Kilowattstunden bis zum nächsten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("energieverbrauch_hilfsbetriebe_kwh", Required = Newtonsoft.Json.Required.Always)]
        public int Energieverbrauch_hilfsbetriebe_kwh { get; set; }

        /// <summary>
        /// Traktions-Energieverbrauch in Kilowattstunden bis zum nächsten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("energieverbrauch_traktion_kwh", Required = Newtonsoft.Json.Required.Always)]
        public int Energieverbrauch_traktion_kwh { get; set; }

        /// <summary>
        /// Energieverbrauch der Wagen in Kilowattstunden bis zum nächsten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("energieverbrauch_wagen_kwh", Required = Newtonsoft.Json.Required.Always)]
        public int Energieverbrauch_wagen_kwh { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die Fahrzeitinfo umfasst die An- und Abfahrtszeit des Zuges an einem Routenpunkt in Minuten seit Abfahrt am Start der Route
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Fahrzeit_info
    {

        /// <summary>
        /// Abfahrtszeit in Minuten seit Abfahrt am Start der Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("abfahrt_min", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Abfahrt_min { get; set; }

        /// <summary>
        /// Ankunftszeit in Minuten seit Abfahrt am Start der Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ankunft_min", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Ankunft_min { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Geographische Koordinaten
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Geo_koordinaten
    {

        /// <summary>
        /// Geopgraphische Breite
        /// </summary>
        [Newtonsoft.Json.JsonProperty("breite", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(-90D, 90D)]
        public double Breite { get; set; }

        /// <summary>
        /// Geographische Länge
        /// </summary>
        [Newtonsoft.Json.JsonProperty("laenge", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(-180D, 180D)]
        public double Laenge { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Prozentuale Gewichtung der Kriterien Streckenlänge, Fahrzeit und Energieverbrauch
    /// <br/>bei der Routensuche. Die Summe der Werte muss 100% ergeben.
    /// <br/>Bsp.: Bei 100% Weglänge wird die kürzest mögliche Route gesucht.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Gewichtung_parameter
    {

        /// <summary>
        /// Prozentuale Gewichtung der Energie
        /// </summary>
        [Newtonsoft.Json.JsonProperty("energie_prozent", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 100)]
        public int Energie_prozent { get; set; }

        /// <summary>
        /// Prozentuale Gewichtung der Fahrzeit
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fahrzeit_prozent", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 100)]
        public int Fahrzeit_prozent { get; set; }

        /// <summary>
        /// Prozentuale Gewichtung der Streckenlänge
        /// </summary>
        [Newtonsoft.Json.JsonProperty("streckenlaenge_prozent", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 100)]
        public int Streckenlaenge_prozent { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die vorhandene Last und die erlaubte Regelgrenzlast bis zum nächsten Routenpunkt
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Grenzlast_info
    {

        /// <summary>
        /// Regelgrenzlast des Streckensegments in Tonnen
        /// </summary>
        [Newtonsoft.Json.JsonProperty("regelgrenzlast", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Regelgrenzlast { get; set; }

        /// <summary>
        /// Durch die Wagenzugmasse erzeugte Last in Tonnen
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vorhandene_last", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Vorhandene_last { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die Infrastruktur umfasst den Ordnungsrahmen und die Stammdaten des Netzes für ein Fahrplanjahr.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Infrastruktur
    {

        /// <summary>
        /// Name der Infrastruktur
        /// <br/>Bsp.: Jahresfahrplan 2019 (12.4)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("anzeigename", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength = 3)]
        public string Anzeigename { get; set; }

        /// <summary>
        /// Fahrplanjahr der Infrastruktur
        /// <br/>Bsp.: 2019
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fahrplanjahr", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 9999)]
        public int Fahrplanjahr { get; set; }

        /// <summary>
        /// Enddatum der Gültigkeit der Infrastruktur
        /// <br/>Bsp.: 2019-05-13
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gueltig_bis", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(10)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset Gueltig_bis { get; set; }

        /// <summary>
        /// Startdatum der Gültigkeit der Infrastruktur
        /// <br/>Bsp.: 2019-05-13
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gueltig_von", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(10)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset Gueltig_von { get; set; }

        /// <summary>
        /// ID der Infrastruktur
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0L, long.MaxValue)]
        public long Id { get; set; }

        /// <summary>
        /// Der Ordnungsrahmen beschreibt das Gleisnetz der Infrastruktur
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ordnungsrahmen", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Ordnungsrahmen Ordnungsrahmen { get; set; } = new Ordnungsrahmen();

        /// <summary>
        /// Die Stammdaten umfassen die Triebfahrzeuge der Infrastruktur
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stammdaten", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Stammdaten Stammdaten { get; set; } = new Stammdaten();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Enthält Informationen zu einer Infrastruktur. Beinhaltet anders als die Infrastruktur keine Triebfahrzeuge und keine Kartendaten
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Infrastruktur_summary
    {

        /// <summary>
        /// Anzeigename der Infrastruktur
        /// <br/>Bsp.: Jahresfahrplan 2019
        /// </summary>
        [Newtonsoft.Json.JsonProperty("anzeigename", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength = 3)]
        public string Anzeigename { get; set; }

        /// <summary>
        /// Fahrplanjahr der Infrastruktur
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fahrplanjahr", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 9999)]
        public int Fahrplanjahr { get; set; }

        /// <summary>
        /// Enddatum der Infrastruktur im Datenformat ISO 8601.
        /// <br/>Bsp.: 2018-12-03
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gueltig_bis", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(10)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset Gueltig_bis { get; set; }

        /// <summary>
        /// Startdatum der Infrastruktur im Datenformat ISO 8601.
        /// <br/>Bsp.: 2018-12-03
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gueltig_von", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(10)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset Gueltig_von { get; set; }

        /// <summary>
        /// ID der Infrastruktur
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0L, long.MaxValue)]
        public long Id { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Invalid_request_error
    {

        /// <summary>
        /// Details zur Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(10)]
        public System.Collections.Generic.ICollection<string> Details { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// Nachricht der Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1000)]
        public string Message { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// KV-Profil in C/P-Kodifizierung. "N/N" repräsentiert ein KV-Profil ohne Einschränkung.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Kv_profil
    {

        /// <summary>
        /// Code C als Ganzzahl oder "N" bei KV-Profil "N/N"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("c", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(3)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^([0-9]+|N)$")]
        public string C { get; set; }

        /// <summary>
        /// Code P als Ganzzahl oder "N" bei KV-Profil "N/N"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("p", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(3)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^([0-9]+|N)$")]
        public string P { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Betriebsstelle, die mögliche Tochterbetriebsstellen enthält
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Mutter_betriebsstelle
    {

        /// <summary>
        /// DS100 (Ril 100) der Betriebsstelle
        /// <br/>Bsp.: 'FMZ', 'RF', 'TS', aber nicht 'TS N'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ds100", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(5, MinimumLength = 2)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z][A-Z0-9 ]{0,3}[A-Z0-9]$")]
        public string Ds100 { get; set; }

        /// <summary>
        /// Die geographischen Koordinaten der Betriebsstelle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("geo_koordinaten", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Geo_koordinaten Geo_koordinaten { get; set; }

        /// <summary>
        /// Langname der Betriebsstelle
        /// <br/>Bsp.: 'Mainz Hbf', 'Freiburg (Breisgau) Hbf', 'Stuttgart Hbf'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("langname", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength = 2)]
        public string Langname { get; set; }

        /// <summary>
        /// Liste der DS100 (Ril 100) aller Tochterbetriebsstellen
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tochterbetriebsstellen", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(50)]
        public System.Collections.Generic.ICollection<string> Tochterbetriebsstellen { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Not_found_error
    {

        /// <summary>
        /// Details zur Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(10)]
        public System.Collections.Generic.ICollection<string> Details { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// Nachricht der Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1000)]
        public string Message { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Der Ordnungsrahmen beschreibt das Gleisnetz der Infrastruktur
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Ordnungsrahmen
    {

        /// <summary>
        /// Betriebsstellen des Ordungsrahmens
        /// </summary>
        [Newtonsoft.Json.JsonProperty("betriebsstellen", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(12000)]
        public System.Collections.Generic.ICollection<Betriebsstelle> Betriebsstellen { get; set; } = new System.Collections.ObjectModel.Collection<Betriebsstelle>();

        /// <summary>
        /// Mutter-Betriebsstellen des Ordungsrahmens
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mutter_betriebsstellen", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(2000)]
        public System.Collections.Generic.ICollection<Mutter_betriebsstelle> Mutter_betriebsstellen { get; set; } = new System.Collections.ObjectModel.Collection<Mutter_betriebsstelle>();

        /// <summary>
        /// Streckensegemente des Ordungsrahmens
        /// </summary>
        [Newtonsoft.Json.JsonProperty("streckensegmente", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(30000)]
        public System.Collections.Generic.ICollection<Streckensegment> Streckensegmente { get; set; } = new System.Collections.ObjectModel.Collection<Streckensegment>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die Route besteht aus einer Liste von Routenpunkten die beginnend am ersten Wegpunkt Startbetriebsstelle hin zu einer Endbetriebsstelle
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Route
    {

        /// <summary>
        /// Maximalwerte für die Grenzlast, das KV-Profil und andere Parameter
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maximalwerte", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Route_maximalwerte Maximalwerte { get; set; } = new Route_maximalwerte();

        /// <summary>
        /// Bei der Trassenpreisberechnung mit dem Marktsegment Punkt-zu-Punkt, gibt dieser Wert an, ob die Route die Geschwindigkeitskriterien des Marktsegments verletzt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("punkt_zu_punkt_geschwindigkeit_unzulaessig", Required = Newtonsoft.Json.Required.Always)]
        public bool Punkt_zu_punkt_geschwindigkeit_unzulaessig { get; set; }

        /// <summary>
        /// Realistische Abfahrtszeit inklusive Datum und Zeitverschiebung in einem ISO 8601- und RFC 3339-konformen Format.
        /// <br/>Bsp.: 2019-05-13T16:38:36+02:00
        /// </summary>
        [Newtonsoft.Json.JsonProperty("realistische_abfahrt", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(25)]
        public System.DateTimeOffset Realistische_abfahrt { get; set; }

        /// <summary>
        /// Typ der Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("routen_typ", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Routen_typ Routen_typ { get; set; }

        /// <summary>
        /// Routenpunkte, die den Verlauf der Route abbilden
        /// </summary>
        [Newtonsoft.Json.JsonProperty("routenpunkte", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(2000)]
        public System.Collections.Generic.ICollection<Routenpunkt> Routenpunkte { get; set; } = new System.Collections.ObjectModel.Collection<Routenpunkt>();

        /// <summary>
        /// Technische Abfahrtszeit inklusive Datum und Zeitverschiebung in einem ISO 8601- und RFC 3339-konformen Format.
        /// <br/>Bsp.: 2019-05-13T16:38:36+02:00
        /// </summary>
        [Newtonsoft.Json.JsonProperty("technische_abfahrt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(25)]
        public System.DateTimeOffset Technische_abfahrt { get; set; }

        /// <summary>
        /// Zusammenfassung der berechneten Route. Diese enthält die Gesamtfahrzeit, die Weglänge, den Trassenpreis und weitere Informationen zur gesamten Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zusammenfassung", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Route_zusammenfassung Zusammenfassung { get; set; } = new Route_zusammenfassung();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Enthält die Maximalwerte für Grenzlast, KV-Profil und Streckenklasse, die auf der Route zulässig sind.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Route_maximalwerte
    {

        /// <summary>
        /// Die maximal zulässige längenabhängige Grenzlast der Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("grenzlast_laengenabhaengig", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 9999)]
        public int Grenzlast_laengenabhaengig { get; set; }

        /// <summary>
        /// Die maximal zulässige längenunabhängige Grenzlast der Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("grenzlast_laengenunabhaengig", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 9999)]
        public int Grenzlast_laengenunabhaengig { get; set; }

        /// <summary>
        /// Das größte auf der Route erlaubte KV-Profil
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kv_profil", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Kv_profil Kv_profil { get; set; } = new Kv_profil();

        /// <summary>
        /// Die höchste auf der Route erlaubte Streckenklasse
        /// </summary>
        [Newtonsoft.Json.JsonProperty("streckenklasse", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(3)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z1-9]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Route_maximalwerteStreckenklasse Streckenklasse { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Zusammenfassung der berechneten Route. Diese enthält die Gesamtfahrzeit, die Weglänge, den Trassenpreis und weitere Informationen zur gesamten Route
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Route_zusammenfassung
    {

        /// <summary>
        /// Energieverbrauch in Kilowattstunden
        /// </summary>
        [Newtonsoft.Json.JsonProperty("energieverbrauch_kwh", Required = Newtonsoft.Json.Required.Always)]
        public int Energieverbrauch_kwh { get; set; }

        /// <summary>
        /// Realistische Fahrzeit in Minuten
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fahrzeit_realistisch_min", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 4320)]
        public int Fahrzeit_realistisch_min { get; set; }

        /// <summary>
        /// Technische Fahrzeit in Minuten
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fahrzeit_technisch_min", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 4320)]
        public int Fahrzeit_technisch_min { get; set; }

        /// <summary>
        /// Kosten für Fahrzeuge und Personal in Euro
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kosten_fahrzeuge_personal_euro", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Kosten_fahrzeuge_personal_euro { get; set; }

        /// <summary>
        /// Marktsegment der Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marktsegment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(30)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Route_zusammenfassungMarktsegment Marktsegment { get; set; }

        /// <summary>
        /// Kosten für Nachschieben in Euro
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nachschiebekosten_euro", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Nachschiebekosten_euro { get; set; }

        /// <summary>
        /// Preis für Energie in Euro
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preis_energie_euro", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Preis_energie_euro { get; set; }

        /// <summary>
        /// Stationspreis in Euro
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stationspreis_euro", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Stationspreis_euro { get; set; }

        /// <summary>
        /// Trassenpreis in Euro
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trassenpreis_euro", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Trassenpreis_euro { get; set; }

        /// <summary>
        /// Weglänge in Hektometern
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weglaenge_hm", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Weglaenge_hm { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Repräsentiert einen Punkt der Route, der vom Zug durchfahren wird
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Routenpunkt
    {

        /// <summary>
        /// Gibt an, mit welchem zweiten Triebfahrzeug gefahren wurde
        /// </summary>
        [Newtonsoft.Json.JsonProperty("abweichendes_zweites_triebfahrzeug_key", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Triebfahrzeug_key Abweichendes_zweites_triebfahrzeug_key { get; set; }

        /// <summary>
        /// Begegnungsverbot im Betriebsstellenfahrweg
        /// </summary>
        [Newtonsoft.Json.JsonProperty("begegnungsverbot", Required = Newtonsoft.Json.Required.Always)]
        public bool Begegnungsverbot { get; set; }

        /// <summary>
        /// Bemerkungen zum Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bemerkungen", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(20)]
        public System.Collections.Generic.ICollection<Bemerkung> Bemerkungen { get; set; } = new System.Collections.ObjectModel.Collection<Bemerkung>();

        /// <summary>
        /// DS100 (Ril 100) der Betriebsstelle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ds100", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(5, MinimumLength = 2)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z][A-Z0-9 ]{0,3}[A-Z0-9]$")]
        public string Ds100 { get; set; }

        /// <summary>
        /// Die Energieverbrauchswerte in Kilowattstunden bis zum nächten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("energieverbrauch_info", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Energieverbrauch_info Energieverbrauch_info { get; set; } = new Energieverbrauch_info();

        /// <summary>
        /// Energieverbrauchs-Kosten in Euro bis zum nächsten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("energieverbrauch_kosten_euro", Required = Newtonsoft.Json.Required.Always)]
        public int Energieverbrauch_kosten_euro { get; set; }

        /// <summary>
        /// Realistische Geschwindigkeit in Hektometern pro Stunde
        /// </summary>
        [Newtonsoft.Json.JsonProperty("geschwindigkeit_realistisch_hmh", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Geschwindigkeit_realistisch_hmh { get; set; }

        /// <summary>
        /// Technische Geschwindigkeit in Hektometern pro Stunde
        /// </summary>
        [Newtonsoft.Json.JsonProperty("geschwindigkeit_technisch_hmh", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Geschwindigkeit_technisch_hmh { get; set; }

        /// <summary>
        /// Gleiswechselbetrieb im Betriebsstellenfahrweg
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gleiswechselbetrieb", Required = Newtonsoft.Json.Required.Always)]
        public bool Gleiswechselbetrieb { get; set; }

        /// <summary>
        /// Die vorhandene Last und die erlaubte Regelgrenzlast bis zum nächsten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("grenzlast_info", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Grenzlast_info Grenzlast_info { get; set; }

        /// <summary>
        /// Haltart am Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("haltart", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RoutenpunktHaltart Haltart { get; set; }

        /// <summary>
        /// Halteplatzsprungart am Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("halteplatz_sprungart", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RoutenpunktHalteplatz_sprungart Halteplatz_sprungart { get; set; }

        /// <summary>
        /// Gibt an, ob der Halteplatz zu kurz ist
        /// </summary>
        [Newtonsoft.Json.JsonProperty("halteplatz_zu_kurz", Required = Newtonsoft.Json.Required.Always)]
        public bool Halteplatz_zu_kurz { get; set; }

        /// <summary>
        /// Gibt an, ob Streckenabschnitte mit umfangreichen Einschraenkungen passiert werden. Bei den Einschränkungen kann es sich z. B. um Baumaßnahmen oder Stellwerkschließungen handeln.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hat_kritische_einschraenkung", Required = Newtonsoft.Json.Required.Always)]
        public bool Hat_kritische_einschraenkung { get; set; }

        /// <summary>
        /// Kosten für Fahrzeuge und Personal in Euro bis zum nächsten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kosten_fahrzeuge_personal_euro", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Kosten_fahrzeuge_personal_euro { get; set; }

        /// <summary>
        /// Weglänge der Route bis zu diesem Routenpunkt in Hektometern 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("laufende_hm", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Laufende_hm { get; set; }

        /// <summary>
        /// Marktsegmente bis zum nächsten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marktsegmente", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.MaxLength(3)]
        public System.Collections.Generic.ICollection<Marktsegmente> Marktsegmente { get; set; }

        /// <summary>
        /// Kosten für Nachschieben in Euro bis zum nächsten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nachschiebekosten_euro", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Nachschiebekosten_euro { get; set; }

        /// <summary>
        /// Schlüssel des nachfolgenden Streckensegments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("naechstes_streckensegment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Streckensegment_key Naechstes_streckensegment { get; set; }

        /// <summary>
        /// Der Primary Location Code der Betriebsstelle innerhalb Europas (eindeutige Betriebsstellen-Nr.)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("primary_location_code", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(7, MinimumLength = 7)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{2}[0-9]{5}$")]
        public string Primary_location_code { get; set; }

        /// <summary>
        /// Die realistischen An- und Abfahrtszeit des Zuges an einem Routenpunkt in Minuten seit Abfahrt am Start der Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("realistische_fahrzeit_info", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Fahrzeit_info Realistische_fahrzeit_info { get; set; }

        /// <summary>
        /// Schiebelokkupplungsart am Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schiebelok_kupplungsart", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(30)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RoutenpunktSchiebelok_kupplungsart Schiebelok_kupplungsart { get; set; }

        /// <summary>
        /// Stationspreis der Betriebsstelle in Euro
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stationspreis_euro", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int Stationspreis_euro { get; set; }

        /// <summary>
        /// Informationen zum ausgehenden Streckensegment
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strecke_info", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Strecke_info Strecke_info { get; set; }

        /// <summary>
        /// Die technischen An- und Abfahrtszeit des Zuges an einem Routenpunkt in Minuten seit Abfahrt am Start der Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("technische_fahrzeit_info", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Fahrzeit_info Technische_fahrzeit_info { get; set; } = new Fahrzeit_info();

        /// <summary>
        /// Gibt an, ob bei Hybridfahrzeugen ein Traktionsartwechsel stattfindet
        /// </summary>
        [Newtonsoft.Json.JsonProperty("traktionsartwechsel_bei_hybridfahrzeug", Required = Newtonsoft.Json.Required.Always)]
        public bool Traktionsartwechsel_bei_hybridfahrzeug { get; set; }

        /// <summary>
        /// Trassenpreis in Euro bis zum nächsten Routenpunkt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trassenpreis_euro", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Trassenpreis_euro { get; set; }

        /// <summary>
        /// Gibt an, mit welchem Triebfahrzeug gefahren wurde
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triebfahrzeug_key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Triebfahrzeug_key Triebfahrzeug_key { get; set; } = new Triebfahrzeug_key();

        /// <summary>
        /// Gibt an, um wie viele Tonnen die Regelgrenzlast überschritten wird
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ueberschreitung_regelgrenzlast", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Ueberschreitung_regelgrenzlast { get; set; }

        /// <summary>
        /// Gibt an, ob ein Verkehrshalt trotz fehlendem Bahnsteig stattfinden soll
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verkehrshalt_trotz_fehlendem_bahnsteig", Required = Newtonsoft.Json.Required.Always)]
        public bool Verkehrshalt_trotz_fehlendem_bahnsteig { get; set; }

        /// <summary>
        /// Falls der Routenpunkt einem bestellten Wegpunkt zugeordnet ist, entspricht der Wegpunktindex der Position des Wegpunks in der Liste der bestellten Wegpunkte, beginnend bei 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wegpunkt_index", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Wegpunkt_index { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Zeigt Informationen für den Fehlschlag der Routensuche an
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Routensuche_failure
    {

        /// <summary>
        /// Ortsbezogene Details zu den Ursachen des Fehlschlags der Routesuche
        /// </summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(100)]
        public System.Collections.Generic.ICollection<Detail> Details { get; set; } = new System.Collections.ObjectModel.Collection<Detail>();

        /// <summary>
        /// Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(128)]
        public string Message { get; set; }

        /// <summary>
        /// Wegpunktbezogene Details zu den Ursachen des Fehlschlags der Routesuche
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wegpunkt_details", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(100)]
        public System.Collections.Generic.ICollection<Wegpunkt_detail> Wegpunkt_details { get; set; } = new System.Collections.ObjectModel.Collection<Wegpunkt_detail>();

        /// <summary>
        /// Index des Wegpunkts, von dem aus keine weiterführende Route gefunden werden konnte
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wegpunkt_index", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 101)]
        public int Wegpunkt_index { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Enthält alle Parameter, die für die Berechnung einer Route notwendig sind
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Routensuche_request
    {

        /// <summary>
        /// Infrastruktur-ID der Infrastruktur auf der die Berechungen durchgeführt wurden
        /// </summary>
        [Newtonsoft.Json.JsonProperty("infrastruktur_id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0L, long.MaxValue)]
        public long Infrastruktur_id { get; set; }

        /// <summary>
        /// Nutzerdefinierte Sperrungen sind Streckenabschnitte, auf denen der Zug nicht verkehren darf
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nutzer_sperrungen", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.MaxLength(10000)]
        public System.Collections.Generic.ICollection<Streckensegment_key> Nutzer_sperrungen { get; set; }

        /// <summary>
        /// Sucheinstellungen für die Routensuche
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sucheinstellungen", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Sucheinstellungen Sucheinstellungen { get; set; } = new Sucheinstellungen();

        /// <summary>
        /// Wegpunkte, zwischen denen eine Route verlaufen soll
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wegpunkte", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(2)]
        [System.ComponentModel.DataAnnotations.MaxLength(102)]
        public System.Collections.Generic.ICollection<Wegpunkt> Wegpunkte { get; set; } = new System.Collections.ObjectModel.Collection<Wegpunkt>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Enthält das Ergebnis der Routensuche. Beinhaltet bis zu vier unterschiedliche Routen oder mögliche Fehlernachrichten, wenn keine Route gefunden wurde
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Routensuche_response
    {

        /// <summary>
        /// Zeigt Informationen über den Fehlschlag der Routensuche an
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failure", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Routensuche_failure Failure { get; set; }

        /// <summary>
        /// Ergebnis der Routensuche
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Routensuche_result Result { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Ergebnis der Routensuche
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Routensuche_result
    {

        /// <summary>
        /// Gibt an, ob es Einschränkungen wie beispielsweise Baumaßnahmen im Fahrzeitraum gibt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("einschraenkungen_in_fahrzeitraum", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Einschraenkungen_in_fahrzeitraum { get; set; }

        /// <summary>
        /// Gewichtete Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gewichtete_route", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Route Gewichtete_route { get; set; } = new Route();

        /// <summary>
        /// Eindeutige ID
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength = 1)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z0-9]+$")]
        public string Id { get; set; }

        /// <summary>
        /// Kürzeste Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kuerzeste_route", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Route Kuerzeste_route { get; set; }

        /// <summary>
        /// Schnellste Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schnellste_route", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Route Schnellste_route { get; set; }

        /// <summary>
        /// Sparsamste Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sparsamste_route", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Route Sparsamste_route { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die Stammdaten umfassen die Triebfahrzeuge der Infrastruktur
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Stammdaten
    {

        /// <summary>
        /// Alle Triebfahrzeuge der Stammdaten
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triebfahrzeuge", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(500)]
        public System.Collections.Generic.ICollection<Triebfahrzeug> Triebfahrzeuge { get; set; } = new System.Collections.ObjectModel.Collection<Triebfahrzeug>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Informationen zum ausgehenden Streckensegment
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Strecke_info
    {

        /// <summary>
        /// Gibt an, ob das Streckensegment bis zum nächsten Routenpunkt außerhalb des DB-Netzes liegt
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ausserhalb_db_netz", Required = Newtonsoft.Json.Required.Always)]
        public bool Ausserhalb_db_netz { get; set; }

        /// <summary>
        /// Gibt an, ob die Grenzlast des Streckensegments bis zum nächsten Routenpunkt ungeprüft ist
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ungeprueft_grenzlast", Required = Newtonsoft.Json.Required.Always)]
        public bool Ungeprueft_grenzlast { get; set; }

        /// <summary>
        /// Gibt an, ob das KV-Profil des Streckensegments bis zum nächsten Routenpunkt ungeprüft ist
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ungeprueft_kv", Required = Newtonsoft.Json.Required.Always)]
        public bool Ungeprueft_kv { get; set; }

        /// <summary>
        /// Gibt an, ob die Streckenklasse des Streckensegments bis zum nächsten Routenpunkt ungeprüft ist
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ungeprueft_streckenklasse", Required = Newtonsoft.Json.Required.Always)]
        public bool Ungeprueft_streckenklasse { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Ein Streckensegment ist ein gerichteter Teilabschnitt einer VZG-Strecke, der durch eine Von- und eine Bis-Betriebsstelle begrenzt ist.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Streckensegment
    {

        /// <summary>
        /// DS100 (Ril 100) der Zielbetriebsstelle des Streckensegments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bis", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(5, MinimumLength = 2)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z][A-Z0-9 ]{0,3}[A-Z0-9]$")]
        public string Bis { get; set; }

        /// <summary>
        /// Kilometrierung am Ende des Streckensegments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bis_km", Required = Newtonsoft.Json.Required.Always)]
        public double Bis_km { get; set; }

        /// <summary>
        /// Streckennummer des Streckensegments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("streckennummer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 9999)]
        public int Streckennummer { get; set; }

        /// <summary>
        /// DS100 (Ril 100) der Startbetriebsstelle des Streckensegments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("von", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(5, MinimumLength = 2)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z][A-Z0-9 ]{0,3}[A-Z0-9]$")]
        public string Von { get; set; }

        /// <summary>
        /// Kilometrierung am Anfang des Streckensegments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("von_km", Required = Newtonsoft.Json.Required.Always)]
        public double Von_km { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Eindeutiger Identifikator eines Streckensegmentes
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Streckensegment_key
    {

        /// <summary>
        /// DS100 (Ril 100) der Zielbetriebsstelle des Streckensegments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bis", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(5, MinimumLength = 2)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z][A-Z0-9 ]{0,3}[A-Z0-9]$")]
        public string Bis { get; set; }

        /// <summary>
        /// Streckennummer des Streckensegments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("streckennummer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 9999)]
        public int Streckennummer { get; set; }

        /// <summary>
        /// DS100 (Ril 100) der Startbetriebsstelle des Streckensegments
        /// </summary>
        [Newtonsoft.Json.JsonProperty("von", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(5, MinimumLength = 2)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z][A-Z0-9 ]{0,3}[A-Z0-9]$")]
        public string Von { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die Sucheinstellungen enthalten alle Parameter, die für die Routensuche verwendet werden
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Sucheinstellungen
    {

        /// <summary>
        /// Datum, Uhrzeit &amp; Zeitverschiebung der An- oder Abfahrt. Das Datenformat entspricht ISO 8601 und RFC 3339 und ist folgendermaßen aufgebaut:
        /// <br/>* das Datum im Format `YYYY-MM-DD`
        /// <br/>* der Buchstabe `T`
        /// <br/>* die Uhrzeit im Format `HH:MM:SS` (eventuell angegebene Sekundenbruchteile, werden verworfen)
        /// <br/>* die Zeitverschiebung im Format `±HH`, `±HH:MM` oder der Buchstabe `Z` für UTC
        /// <br/>
        /// <br/>Bsp.: 2024-05-13T16:38:36+02:00
        /// </summary>
        [Newtonsoft.Json.JsonProperty("an_abzeit", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(25)]
        public System.DateTimeOffset An_abzeit { get; set; }

        /// <summary>
        /// Falls aktiviert, werden geplante Einschränkungen (Baumaßnahmen und Streckenruhen) der nächsten 70 Tage ab einer Dauer von 2 Stunden beachtet. Züge befahren keine Strecken mit Totalsperrungen. Alle anderen Einschränkungen werden im Ergebnis als Bemerkungen ausgegeben.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("einschraenkungen_beachten", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Einschraenkungen_beachten { get; set; }

        /// <summary>
        /// Falls aktiviert, wird bei Bedarf Einzelgrenzlastberechnung genutzt. Der Trassenfinder erhöht künstlich die Grenzlasten, um mehr Streckenabschnitte für das Routing nutzen zu können. Für die Streckenabschnitte, auf denen im Routingergebnis die Regelgrenzlast überschritten wurde, ist eine EGB über https://www.dbinfrago.com/greta zu bestellen!
        /// </summary>
        [Newtonsoft.Json.JsonProperty("einzelgrenzlastberechnung_zulaessig", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Einzelgrenzlastberechnung_zulaessig { get; set; }

        /// <summary>
        /// Prozentuale Gewichtung der Kriterien Streckenlänge, Fahrzeit und Energieverbrauch bei der Routensuche. Die Summe der Werte muss 100% ergeben.
        /// <br/>Bsp.: Bei 100% Weglänge wird die kürzest mögliche Route gesucht.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gewichtung_parameter", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Gewichtung_parameter Gewichtung_parameter { get; set; }

        /// <summary>
        /// Gibt an, ob initiale Streckensperrungen berücksichtigt werden sollen. Das heißt, dass entsprechende, bereits in der Infrastruktur gesperrte Streckenabschnitte nicht befahren werden können.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("initiale_sperrungen_beruecksichtigen", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Initiale_sperrungen_beruecksichtigen { get; set; }

        /// <summary>
        /// Gibt an, ob längenbhängige Grenzlasten verwendet werden sollen. Die im Trassenfinder enthaltenen Grenzlastendaten wurden auf 9 Stufen der Wagenzuglänge (300, 350, 400, 450, 500, 550, 600, 650 ,700) umgestellt. Damit ist eine Wagenzuglänge von 275 bis 724 Meter durchgehend abgedeckt. Unterhalb von 275 Metern und oberhalb von 724 Metern Wagenzuglänge wird keine Grenzlastprüfung durchgeführt. Ist diese Option deaktiviert, werden bei jeder Wagenzuglänge die Grenzlastdaten für einen Wagenzug mit 700 Metern verwendet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("laengenabhaengige_grenzlasten_verwenden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Laengenabhaengige_grenzlasten_verwenden { get; set; }

        /// <summary>
        /// Alle Fahrzeiten der Route werden um dem manuellen prozentualen Fahrzeitzuschlag gestreckt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("manueller_fahrzeitzuschlag_prozent", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 50)]
        public int Manueller_fahrzeitzuschlag_prozent { get; set; }

        /// <summary>
        /// Fall aktiviert, verwendet die Fahrzeit-Optimierung der Routensuche realistische Fahrzeiten abhängig von Ort und Tageszeit auf Grundlage real gefahrener Güterzüge. Anderenfalls werden technische Fahrzeiten verwendet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mit_realistischen_fahrzeiten_optimieren", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Mit_realistischen_fahrzeiten_optimieren { get; set; }

        /// <summary>
        /// Durch Aktivieren dieser Option wird nicht nur eine Route mit den Werten aus "gewichtung_parameter" als Optimierungskriterium gefunden, sondern gleichzeitig diejenige mit dem geringsten Trassenpreis und diejenige mit der kürzesten Trassenlänge. Es stehen demzufolge nach der Berechnung bis zu drei Optimierungsvarianten zur Auswahl.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optimierungsvarianten_berechnen", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Optimierungsvarianten_berechnen { get; set; }

        /// <summary>
        /// Mit dem Aktivieren dieser Einstellung lassen Sie zu, dass der Zug beliebige Richtungswechsel durch Umsetzen des Triebfahrzeugs („Kopf machen“) durchführen kann. Ein Richtungswechsel kann nur in Bahnhöfen erfolgen, in denen Fahrstraßen dies zulassen (Gleise mit Einund Ausfahrmöglichkeiten). Am Ort des Richtungswechsels wird ein Betriebshalt mit einer Haltezeit von 30 Minuten in der Verkehrsart SGV bzw. 10 Minuten in allen anderen Verkehrsarten eingerichtet. In den Hinweisen der Laufwegübersicht wird am Ort des Kopfmachens „Richtungswechsel“ eingetragen. Sofern Sie am Ort des Kopfmachens bereits einen Verkehrshalt (ViaPunkt) eingestellt haben, wird dessen Haltedauer übernommen (auch wenn sie kleiner als 30 Minuten ist) und der Halt in einen Kundenhalt (Verkehrshalt) umgestellt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("richtungswechsel_zulaessig", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Richtungswechsel_zulaessig { get; set; }

        /// <summary>
        /// Trassenentgeltparameter für die Berechnung des Trassenentgelts
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trassenentgelt_parameter", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Trassenentgelt_parameter Trassenentgelt_parameter { get; set; }

        /// <summary>
        /// Es stehen folgende Verkehrsarten zur Verfügung:
        /// <br/>* Schienengüterverkehr (SGV), Lokzüge (LZ)
        /// <br/>* Schienpersonennahverkehr mit Lokzügen (SPNV-Lok)
        /// <br/>* Schienpersonennahverkehr mit Triebwagen (SPNV-TW)
        /// <br/>* Schienpersonenfernverkehr mit Lokzügen (SPFV-Lok)
        /// <br/>* Schienpersonenfernverkehr mit Triebwagen (SPFV-TW)
        /// <br/>* S-Bahnen
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verkehrsart", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(10)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SucheinstellungenVerkehrsart Verkehrsart { get; set; }

        /// <summary>
        /// Falls aktiviert, hält der Zug, wenn möglich, an Bahnsteigen.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("verkehrshalte_nur_an_bahnsteigen", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Verkehrshalte_nur_an_bahnsteigen { get; set; }

        /// <summary>
        /// Enthält Parameter die festlegen, ob Streckenabschnitte mit bestimmten Eigenschaften bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“) werden sollen. Dies bedeutet, dass eher alternative Routen ohne diese Streckenabschnitte gefunden werden, auch wenn dies höhere Kosten, längere Wege oder größere Fahrzeiten verursacht.  Grundsätzlich ist, bei aktivierter Funktion, das Fahren über diese Betriebsstellen trotzdem möglich, insbesondere dann, wenn sich dort Zwangspunkte (Beginn-, Via- oder Endpunkt) befinden oder dadurch ein übermäßig großer Umweg entstehen würde.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vermeidung_parameter", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Vermeidung_parameter Vermeidung_parameter { get; set; }

        /// <summary>
        /// Wendezeit des Zuges in Minuten. Sie gibt an, wie lange ein Zug hält, falls er abseits der bestellten Halte kopfmachen muss.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wendezeit_min", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 2147483647)]
        public int Wendezeit_min { get; set; }

        /// <summary>
        /// Es stehen folgende Optionen zur Verfügung:
        /// <br/>* Abzeit (feste Abfahrtszeit)
        /// <br/>* Anzeit (feste Ankunftszeit)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zeitvorgabe_typ", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(10)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SucheinstellungenZeitvorgabe_typ Zeitvorgabe_typ { get; set; }

        /// <summary>
        /// Zusatzkostenparameter für die Prognose der Energie-, Fahrzeug- und Personalkosten der Route
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zusatzkosten_parameter", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Zusatzkosten_parameter Zusatzkosten_parameter { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Timeout_error
    {

        /// <summary>
        /// Details zur Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(10)]
        public System.Collections.Generic.ICollection<string> Details { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// Nachricht der Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1000)]
        public string Message { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Too_many_requests
    {

        /// <summary>
        /// Details zur Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(10)]
        public System.Collections.Generic.ICollection<string> Details { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// Nachricht der Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1000)]
        public string Message { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Trassenentgeltparameter für die Berechnung des Trassenentgelts
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Trassenentgelt_parameter
    {

        /// <summary>
        /// Flexibilität der räumlichen oder zeitlichen Fahrplangestatlung. Die Flexibilität beeinflusst das Trassenentgelt. Die räumliche Flexibilität besagt, dass bei der bezüglich der räumlichen Fahrplangestaltung flexibel ist. Die zeitliche Flexibilität besagt, dass der ein Endkunde bezüglich der zeitlichen Fahrplangestaltung flexibel ist. Eine höhere Flexibilität führt zu niedrigeren Kosten
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flexibilitaet", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Trassenentgelt_parameterFlexibilitaet Flexibilitaet { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug ausschließlich gefährliche Güter transportiert. Diese Angabe ist nur im Schienengüterverkehr gültig und sorgt für ein erhöhtes Trassenentgelt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gefahrgutganzzug", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Gefahrgutganzzug { get; set; }

        /// <summary>
        /// Gibt das Marktsegement an. Das Marktsegement beeinflusst das Trassenentgelt.
        /// <br/>Bsp.: Das Marktsegment Lok-/Leerfahrt führt zu geringeren Kosten als das Marktsegment Metro Tag/Basic/Nacht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marktsegment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(30)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Trassenentgelt_parameterMarktsegment Marktsegment { get; set; }

        /// <summary>
        /// Priorität der betrieblichen Durchführung. Züge mit höherer Priorität kosten mehr Trassenentgelt. Züge mit der Priorität 'Schnell' haben eine hohe Priorität und damit Vorrang vor anderen Zügen des Schienengüter- und Schienenpersonenverkehrs mit normaler Priorität. Züge mit der normaler und hoher Priorität. Züge des Schienenpersonenfernverkehrs mit dem Zusatz 'Express' haben außerdem Vorrang von Güterzügen mit Zusatz Express.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prioritaet", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Trassenentgelt_parameterPrioritaet Prioritaet { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Ein elektrisch oder verbrennungsmotorisch betriebenes Fahrzeug
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Triebfahrzeug
    {

        /// <summary>
        /// Gibt an, ob das Triebfahrzeug die aktive Neigetechnik verwendet. Wenn die aktive Neigetechnik verwendet wird, können Kurven schneller befahren werden. Das beinflusst die Durchschnittsgeschwindigkeit des Triebfahrzeugs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aktive_neigetechnik", Required = Newtonsoft.Json.Required.Always)]
        public bool Aktive_neigetechnik { get; set; }

        /// <summary>
        /// Baureihennamen des Triebfahrzeugs
        /// <br/>Bsp.: 'DB 003' oder 'ÖBB 1044 / ÖBB 1144'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("baureihenname", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(30, MinimumLength = 1)]
        public string Baureihenname { get; set; }

        /// <summary>
        /// Bezeichnung des Triebfahrzeugs
        /// <br/>Bsp.: 'Mehrsystemlok, Pu=5,6MW'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bezeichnung", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength = 1)]
        public string Bezeichnung { get; set; }

        /// <summary>
        /// Gibt an, ob das Triebfahrzeug elektrifiziert ist. Eine Aktivierung führt dazu, dass nur elektrifizierte Streckenabschnitte befahren werden können
        /// </summary>
        [Newtonsoft.Json.JsonProperty("elektrifiziert", Required = Newtonsoft.Json.Required.Always)]
        public bool Elektrifiziert { get; set; }

        /// <summary>
        /// Hauptnummer des Triebfahrzeugs. Dient zusammen mit der Unternummer, der Kennung und dem Kennungswert dazu, das Triebfahrzeug eindeutig zu identifizieren
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hauptnummer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(6, MinimumLength = 1)]
        public string Hauptnummer { get; set; }

        /// <summary>
        /// Kennung des Triebfahrzeugs. Dient zusammen mit der Hauptnummer, der Unternummer und dem Kennungswert dazu, das Triebfahrzeug eindeutig zu identifizieren
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kennung", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(3)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TriebfahrzeugKennung Kennung { get; set; }

        /// <summary>
        /// Kennungswert des Triebfahrzeugs. Dient zusammen mit der Hauptnummer, der Unternummer und der Kennung dazu, das Triebfahrzeug eindeutig zu identifizieren
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kennung_wert", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 9999)]
        public int Kennung_wert { get; set; }

        /// <summary>
        /// Gibt an, dass mit diesem Triebfahrzeug ein Traktionsartwechsel durchgeführt werden kann. Das zugehörige Triebfahrzeug weist denselben Wert auf
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partner_tfz_fuer_traktionsartwechsel", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Triebfahrzeug_key Partner_tfz_fuer_traktionsartwechsel { get; set; }

        /// <summary>
        /// Gibt an, ob das Triebfahrzeug als Triebwagen eingesetzt wird
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triebwagen", Required = Newtonsoft.Json.Required.Always)]
        public bool Triebwagen { get; set; }

        /// <summary>
        /// Unternummer des Triebfahrzeugs. Dient zusammen mit der Hauptnummer, der Kennung und dem Kennungswert dazu, das Triebfahrzeug eindeutig zu identifizieren
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unternummer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 99)]
        public int Unternummer { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Eindeutiger Identifikator eines Triebfahrzeugs bestehend aus den Parameter Hauptnummer, Unternummer, Kennung und Kennungwert.
    /// <br/>Bsp.: {hauptnummer: "6185", unternummer: 2, kennung: "L", kennung_wert: 80}
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Triebfahrzeug_key
    {

        /// <summary>
        /// Hauptnummer des Triebfahrzeugs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hauptnummer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(6, MinimumLength = 1)]
        public string Hauptnummer { get; set; }

        /// <summary>
        /// Kennung des Triebfahrzeugs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kennung", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(3)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Triebfahrzeug_keyKennung Kennung { get; set; }

        /// <summary>
        /// Kennungswert des Triebfahrzeugs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kennung_wert", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 9999)]
        public int Kennung_wert { get; set; }

        /// <summary>
        /// Unternummer des Triebfahrzeugs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unternummer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0, 99)]
        public int Unternummer { get; set; }

    }

    /// <summary>
    /// Wird zurückgegeben, wenn während einer Anfrage ein Fehler auftritt
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Unexpected_error
    {

        /// <summary>
        /// Details zur Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(10)]
        public System.Collections.Generic.ICollection<string> Details { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// Nachricht der Fehlermeldung
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(1000)]
        public string Message { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die Informationen zu Fehlern bei einer fehlgeschlagenen Routensuche.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Ursachen
    {

        /// <summary>
        /// Gibt an, ob der Zug die Betriebsstelle auf der Streckennummer aus einem anderen Grund nicht durchfahren konnte. Zum Beispiel, weil keine passenden Fahrwege vorhanden sind.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("anderweitig_unzulaessig", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Anderweitig_unzulaessig { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug die Betriebsstelle auf der Streckennummer aufgrund von DLA-U-Profilen nicht durchfahren konnte.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dla_u_profil_verboten", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Dla_u_profil_verboten { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug die Betriebsstelle auf der Streckennummer aufgrund einer Streckensperrung durch Baumaßnahmen nicht durchfahren konnte.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gesperrt_durch_baumassnahme", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Gesperrt_durch_baumassnahme { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug die Betriebsstelle auf der Streckennummer aufgrund einer Streckensperrung durch den Nutzer nicht durchfahren konnte.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gesperrt_durch_nutzer", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Gesperrt_durch_nutzer { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug die Betriebsstelle auf der Streckennummer aufgrund einer Streckensperrung für Gefahrgutganzzüge nicht durchfahren konnte.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gesperrt_fuer_gefahrgutganzzug", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Gesperrt_fuer_gefahrgutganzzug { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug die Betriebsstelle auf der Streckennummer aufgrund einer Streckensperrung für die Verkehrsart nicht durchfahren konnte.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gesperrt_initial", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Gesperrt_initial { get; set; }

        /// <summary>
        /// Die maximale in der Betriebsstelle auf der Streckennummer zulässige Grenzlast. Der Wert wird ist nur vorhanden, falls er vom Zug überschritten wurde.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_grenzlast", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(-32768, 32767)]
        public int Max_grenzlast { get; set; }

        /// <summary>
        /// Das größte in der Betriebsstelle auf der Streckennummer zulässige KV-Profil. Der Wert wird ist nur vorhanden, falls er vom Zug überschritten wurde.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_kv_profil", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Kv_profil Max_kv_profil { get; set; }

        /// <summary>
        /// Die höchste in der Betriebsstelle auf der Streckennummer zulässige Streckenklasse. Der Wert wird ist nur vorhanden, falls er vom Zug überschritten wurde.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("max_streckenklasse", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(3)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z1-9]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public UrsachenMax_streckenklasse Max_streckenklasse { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug die Betriebsstelle auf der Streckennummer aufgrund fehlender Elektrifizierung nicht durchfahren konnte.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nicht_elektrifiziert", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Nicht_elektrifiziert { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug die Betriebsstelle auf der Streckennummer aufgrund unzulässiger Zugbeeinflussungssysteme nicht durchfahren konnte.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zugbeeinflussung_unzulaessig", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Zugbeeinflussung_unzulaessig { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Vermeidung_parameter
    {

        /// <summary>
        /// Ist diese Funktion aktiviert, wird das Befahren von eingleisigen Streckenabschnitten bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("eingleisige_strecken_meiden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Eingleisige_strecken_meiden { get; set; }

        /// <summary>
        /// Ist diese Funktion aktiviert, wird das Befahren von Knotenbahnhöfen (insbesondere Hauptbahnhöfe ohne Güterdurchgangsverkehr) des Schienenpersonenverkehrs bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("knotenbahnhoefe_meiden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Knotenbahnhoefe_meiden { get; set; }

        /// <summary>
        /// Ist diese Funktion aktiviert, wird das Befahren von Streckenabschnitten, die Nebenbahnen (vgl. EBO) sind, bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nebenbahnen_meiden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Nebenbahnen_meiden { get; set; }

        /// <summary>
        /// Ist diese Funktion aktiviert, wird das Befahren von Streckenabschnitten mit Notbremsüberbrückung bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("notbremsueberbrueckung_meiden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Notbremsueberbrueckung_meiden { get; set; }

        /// <summary>
        /// Ist diese Funktion aktiviert, werden Streckenabschnitte, auf denen im Regelbetrieb vorrangig S-Bahnen verkehren (insbesondere S-Bahn-Stammstrecken in Ballungszentren), bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sbahnen_meiden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Sbahnen_meiden { get; set; }

        /// <summary>
        /// Ist diese Funktion aktiviert, werden Streckenabschnitte, auf denen planmäßig Züge mit mehr als 230 km/h verkehren (insbesondere Neubaustrecken), bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schnellfahrstrecken_meiden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Schnellfahrstrecken_meiden { get; set; }

        /// <summary>
        /// Ist diese Funktion aktiviert, wird das Befahren von Streckenabschnitten mit Vorrang für SGV bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strecken_mit_vorrang_sgv_meiden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Strecken_mit_vorrang_sgv_meiden { get; set; }

        /// <summary>
        /// Ist diese Funktion aktiviert, wird das Befahren von Streckenabschnitten mit Vorrang für SPV bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strecken_mit_vorrang_spv_meiden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Strecken_mit_vorrang_spv_meiden { get; set; }

        /// <summary>
        /// Ist diese Funktion aktiviert, werden Streckenabschnitte, die laut Schienennetz-Benutzungsbedingungen (SNB) als überlasteter Schienenweg ausgewiesen sind, bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ueberlastete_meiden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Ueberlastete_meiden { get; set; }

        /// <summary>
        /// Ist diese Funktion aktiviert, wird das Befahren von Streckenabschnitten mit Wirbelstromertüchtigung bei der Routensuche mit einem Aufschlag als Faktor versehen („bestraft“).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wirbelstrombremse_meiden", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Wirbelstrombremse_meiden { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Versionsinformationen zum Trassenfinder
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Version
    {

        /// <summary>
        /// Versionsnummer des Trassenfinders
        /// </summary>
        [Newtonsoft.Json.JsonProperty("trassenfinder", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        public string Trassenfinder { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Wegpunkt
    {

        /// <summary>
        /// Betriebsstelle des Wegpunkts
        /// </summary>
        [Newtonsoft.Json.JsonProperty("betriebsstelle", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Wegpunkt_betriebsstelle Betriebsstelle { get; set; } = new Wegpunkt_betriebsstelle();

        /// <summary>
        /// Haltezeit in Sekunden. Bei einer Haltezeit von 0 Sekunden wird in der Regel kein Halt eingelegt. Mögliche Ausnahmen sind u. A. Richtungswechsel oder das Ankuppeln einer Schiebelok in der Betriebsstelle des Wegpunkts. Die Haltezeiten des ersten und letzten Wegpunkts werden nicht berücksichtigt. Je nach Verkehrsart gelten unterschiedliche Mindesthaltezeiten.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("haltezeit_sek", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 99999)]
        public int Haltezeit_sek { get; set; }

        /// <summary>
        /// Zugcharakteristik, die ab dem Wegpunkt gilt. Wechsel der Zugcharkateristik sind nur an Halten zulässig.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zugcharakteristik", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Zugcharakteristik Zugcharakteristik { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die Betriebsstelle eines Wegpunktes
    /// <br/>Bsp.: Im Hauptbahnhof der Stadt Mainz können mehrere Wegpunke ausgewählt werden und jeder dieser Wegpunkte beinhaltet genau eine Betriebsstelle
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Wegpunkt_betriebsstelle
    {

        /// <summary>
        /// DS100 (Ril 100) der Betriebsstelle des Wegpunktes
        /// <br/>Bsp.: 'FMZ', 'RF', 'TS'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ds100", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(5, MinimumLength = 2)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z][A-Z0-9 ]{0,3}[A-Z0-9]$")]
        public string Ds100 { get; set; }

        /// <summary>
        /// Gibt an, ob es sich bei der Betriebsstelle um eine Mutterbetriebsstelle handelt.Mutterbetriebsstellen gruppieren mehrere Tochterbetriebsstellen, z.B. die Bahnhofsteile eines größeren Bahnhofs.Die Routensuche wählt unter den Tochterbetriebsstellen automatisch die optimalste aus.
        /// <br/>Bsp.: Die Mutterbetriebsstelle 'NN' umfasst die Tochterbetriebsstellen 'NN' und 'NNSE'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mutter", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Mutter { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die Betriebsstelle und Streckennummer mit zugehöriger Fehleranalyse
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Wegpunkt_detail
    {

        /// <summary>
        /// DS100 (Ril 100) der Betriebsstelle, die der Zug auf der gegebenen Streckennummer nicht durchfahren konnte
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ds100", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(5, MinimumLength = 2)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z][A-Z0-9 ]{0,3}[A-Z0-9]$")]
        public string Ds100 { get; set; }

        /// <summary>
        /// Ursachen dafür, dass der Zug die gegebene Betriebsstelle auf der gegebenen Streckennummer nicht durchfahren konnte
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ursachen", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Wegpunkt_ursachen Ursachen { get; set; } = new Wegpunkt_ursachen();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die Informationen zu Fehlern an Wegpunkten bei einer fehlgeschlagenen Routensuche.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Wegpunkt_ursachen
    {

        /// <summary>
        /// Gibt an, ob der Zug die Betriebsstelle auf der Streckennummer aus einem anderen Grund nicht durchfahren konnte. Zum Beispiel, weil keine passenden Fahrwege vorhanden sind.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("anderweitig_unzulaessig", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Anderweitig_unzulaessig { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug die Betriebsstelle auf der Streckennummer aufgrund von DLA-U-Profilen nicht durchfahren konnte.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dla_u_profil_verboten", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Dla_u_profil_verboten { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Die vom Zug unterstützten Zugbeeinflussungssysteme.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Zugbeeinflussung
    {

        /// <summary>
        /// Unterstützte Systemversion der ETCS-Zugausrüstung.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("etcs_system_version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(50)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ZugbeeinflussungEtcs_system_version Etcs_system_version { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug linienförmige Zugbeeinflussung (LZB) unterstützt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lzb", Required = Newtonsoft.Json.Required.Always)]
        public bool Lzb { get; set; }

        /// <summary>
        /// Gibt an, ob der Zug punktförmige Zugbeeinflussung (PZB) unterstützt.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pzb", Required = Newtonsoft.Json.Required.Always)]
        public bool Pzb { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Beschreibt die Eigenschaften eines Zuges
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Zugcharakteristik
    {

        /// <summary>
        /// Eindeutiger Identifikator eines zweiten Triebfahrzeugs. Nur Anzugeben, wenn die Vorspannart ein abweichendes Triebfahrzeug vorsieht.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("abweichendes_zweites_triebfahrzeug", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Triebfahrzeug_key Abweichendes_zweites_triebfahrzeug { get; set; }

        /// <summary>
        /// Gibt an, ob aktive Neigetechnik verwendet werden soll, sofern das Triebfahrzeug damit ausgerüstet ist. Mit aktiver Neigetechnik können Kurven schneller befahren werden.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aktive_neigetechnik", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Aktive_neigetechnik { get; set; }

        /// <summary>
        /// Betriebliche Festigkeit der Zugkupplung in Kilonewton. Nur anzugeben, wenn die Kupplungsbauart 'andere' ausgewählt wurde.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("andere_kupplungsfestigkeit", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 5000)]
        public int Andere_kupplungsfestigkeit { get; set; }

        /// <summary>
        /// Vorhandende Bremshunderstel des Zuges.  Dieser Wert beeinflusst insbesondere die Fahrzeitberechnung, da bei zu geringer Bremskraft die zulässige (nicht signalisierte) Geschwindigkeit eines Zuges abschnittsweise beschränkt wird. 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bremshundertstel", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 300)]
        public int Bremshundertstel { get; set; }

        /// <summary>
        /// Bremsstellung der Wagenzüge. Die Auswahl beeinflusst insbesondere die Fahrzeitberechnung, da abhängig von der Trägheit der Bremse eine flachere Brems- und Lösekurve unterstellt wird. Es können folgende Bremsstellungen ausgewählt werden.
        /// <br/>* Güterzugbremse (G)
        /// <br/>* Personenzugbremse (P)
        /// <br/>* Rapidbremse (R)
        /// <br/>* Rapidbremse und Magnetschienenbremse (R+Mg)
        /// <br/>* Rapidbremse und Wirbelstrombremse (R+WB)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bremsstellung", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(5)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z+]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ZugcharakteristikBremsstellung Bremsstellung { get; set; }

        /// <summary>
        /// Liste der DLA-U-Profile des Zuges
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dla_u_profile", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MaxLength(4)]
        public System.Collections.Generic.ICollection<Dla_u_profile> Dla_u_profile { get; set; } = new System.Collections.ObjectModel.Collection<Dla_u_profile>();

        /// <summary>
        /// Die Art des führenden Fahrzeugs des Zuges. Bei Steuerwagen wird die gegebene Wagenzuglänge als Zuglänge interpretiert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fuehrendes_fahrzeug", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(20)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ZugcharakteristikFuehrendes_fahrzeug Fuehrendes_fahrzeug { get; set; }

        /// <summary>
        /// Die Kupplungsbauart des Triebfahrzeugs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kupplungsbauart", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(10)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z0-9_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ZugcharakteristikKupplungsbauart Kupplungsbauart { get; set; }

        /// <summary>
        /// KV-Profil (P/C) des Zuges
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kv_profil", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Kv_profil Kv_profil { get; set; } = new Kv_profil();

        /// <summary>
        /// Eindeutiger Identifikator eines Triebfahrzeugs zum Nachschieben. Nur anzugeben, wenn als Nachschiebeart nicht 'ohne' eingestellt wurde.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nachschiebe_triebfahrzeug", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Triebfahrzeug_key Nachschiebe_triebfahrzeug { get; set; }

        /// <summary>
        /// Gibt die Nachschiebeart an.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nachschiebeart", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(50)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ZugcharakteristikNachschiebeart Nachschiebeart { get; set; }

        /// <summary>
        /// Die Streckenklasse des Zuges legt die maximale erlaubte Meter- und Radsatzlast fest. Je nach Streckenklasse des Zuges können bestimmte Streckenabschnitte nicht befahren werden. Die Streckenklasse 'A' besitzt die geringste Radsatz- und Meterlast, lexikographisch höhere Streckenklassen erlauben höhere Radsatz- und Meterlasten.
        /// <br/>Bsp.: Ein Zug mit Streckenklasse C2 darf auf Streckenabschnitten der Streckenklassen A bis C2 verkehren, aber nicht auf Streckenabschnitten der Streckenklasse C3 bis D4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("streckenklasse", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(3)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z1-9]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ZugcharakteristikStreckenklasse Streckenklasse { get; set; }

        /// <summary>
        /// Gibt an, ob ein automatischer Traktionsartwechsel bei Hybridfahrzeugen erfolgen soll'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("traktionsartwechsel", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Traktionsartwechsel { get; set; }

        /// <summary>
        /// Eindeutiger Identifikator eines Triebfahrzeugs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triebfahrzeug", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Triebfahrzeug_key Triebfahrzeug { get; set; } = new Triebfahrzeug_key();

        /// <summary>
        /// Höchstgeschwindigkeit des Zuges in km/h ("Vmax" im Fahrplankopf). Auch wenn das Triebfahrzeug und die Infrastruktur eine höhere Geschwindigkeit zulassen würden, ist die Geschwindigkeit des Zuges auf diesen Wert begrenzt. Dieser Wert beeinflusst insbesondere die Fahrzeitberechnung.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("v_max", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 1000)]
        public int V_max { get; set; }

        /// <summary>
        /// Mit der Auswahl können Sie das ausgewählte Triebfahrzeug um ein zweites gekuppeltes Triebfahrzeug (als Vorspannlok bzw. in Doppeltraktion) der gleichen Baureihe erweitern. Beide Triebfahrzeuge werden in Abhängigkeit des Kupplungstyps (Begrenzung der Zugkraft aufgrund der Zughakengrenzlast) bei der Grenzlastbewertung und Fahrzeitberechnung angerechnet. Sie haben folgende Auswahl für den Kupplungstypen.
        /// <br/>* Standardschraubenkupplung (maximal 450 kN Zugkraft)
        /// <br/>* verstärkte Schraubenkupplung (maximal 500 kN Zugkraft)
        /// <br/>* automatische Kupplung (maximal 850 kN Zugkraft)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vorspannart", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.StringLength(50)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[a-z_]+$")]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ZugcharakteristikVorspannart Vorspannart { get; set; }

        /// <summary>
        /// Wagenzulänge des Zuges in Metern. Diese hat Einfluss auf Fahrzeitberechnung und Halteplatzauswahl.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wagenzuglaenge_m", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 2000)]
        public int Wagenzuglaenge_m { get; set; }

        /// <summary>
        /// Wagenzugmasse des Zuges in Tonnen
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wagenzugmasse_t", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, 100000)]
        public int Wagenzugmasse_t { get; set; }

        /// <summary>
        /// Die vom Zug unterstützten Zugbeeinflussungssysteme. Folgende Zugbeeinflussungssysteme werden unterstützt.
        /// <br/>* Punktförmige Zugbeeinflussung (PZB)
        /// <br/>* Linieförmige Zugbeeinflussung (LZB)
        /// <br/>* European Train Control System (ETCS)
        /// <br/>Die Zugbeeinflussung wirkt sich auf die Fahrzeitrechung aus. Sofern an Streckenabschnitten ein Zwang nach einer bestimmten Zugbeeinflussung (z.B. ETCS) existiert, wird dieser bei der Routensuche geprüft. 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zugbeeinflussung_parameter", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Zugbeeinflussung Zugbeeinflussung_parameter { get; set; } = new Zugbeeinflussung();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Zusatzkostenparameter für die Prognose der Energie-, Fahrzeug- und Personalkosten der Route.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Zusatzkosten_parameter
    {

        /// <summary>
        /// Energiebezugspreis in Euro pro Kilowattstunde
        /// </summary>
        [Newtonsoft.Json.JsonProperty("energiebezugspreis_euro_pro_kwh", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 100D)]
        public double Energiebezugspreis_euro_pro_kwh { get; set; }

        /// <summary>
        /// Gibt an, ob der Energieverbrauch der Hilfsbetriebe und Wagen beachtet werden soll
        /// </summary>
        [Newtonsoft.Json.JsonProperty("energieverbrauch_hilfsbetriebe_und_wagen_beachten", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Energieverbrauch_hilfsbetriebe_und_wagen_beachten { get; set; }

        /// <summary>
        /// Stundenkosten für besetzte Triebfahrzeuge (inkl. Personal) in Euro
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kosten_besetzte_tfz_inkl_personal_euro_pro_h", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 2147483647D)]
        public double Kosten_besetzte_tfz_inkl_personal_euro_pro_h { get; set; }

        /// <summary>
        /// Stundenkosten für nicht besetzte Triebfahrzeuge in Euro
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kosten_unbesetzte_tfz_euro_pro_h", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 2147483647D)]
        public double Kosten_unbesetzte_tfz_euro_pro_h { get; set; }

        /// <summary>
        /// Stundenkosten für Wagenzug in Euro
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kosten_wagenzug_euro_pro_h", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 2147483647D)]
        public double Kosten_wagenzug_euro_pro_h { get; set; }

        /// <summary>
        /// Kostenpauschale für ungekuppeltes Nachschieben in Euro
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kostenpauschale_ungekuppelt_nachschieben_euro", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 2147483647D)]
        public double Kostenpauschale_ungekuppelt_nachschieben_euro { get; set; }

        /// <summary>
        /// Entgelt für Energierückspeisung in Euro pro Kilowattstunde
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rueckspeisung_euro_pro_kwh", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 100D)]
        public double Rueckspeisung_euro_pro_kwh { get; set; }

        /// <summary>
        /// Der zusätzliche Energiebedarf pro Wagen in Kilowattstunden
        /// </summary>
        [Newtonsoft.Json.JsonProperty("zusaetzlicher_energieverbrauch_pro_wagen_kw", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, 2147483647D)]
        public double Zusaetzlicher_energieverbrauch_pro_wagen_kw { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Route2
    {

        [System.Runtime.Serialization.EnumMember(Value = @"kuerzeste")]
        Kuerzeste = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"schnellste")]
        Schnellste = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"sparsamste")]
        Sparsamste = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"gewichtete")]
        Gewichtete = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Route3
    {

        [System.Runtime.Serialization.EnumMember(Value = @"kuerzeste")]
        Kuerzeste = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"schnellste")]
        Schnellste = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"sparsamste")]
        Sparsamste = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"gewichtete")]
        Gewichtete = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Bemerkung_typ
    {

        [System.Runtime.Serialization.EnumMember(Value = @"einschraenkung")]
        Einschraenkung = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"sonstige")]
        Sonstige = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Betriebsstellentypen
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ohne")]
        Ohne = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"abzweigstelle")]
        Abzweigstelle = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"anschlussstelle")]
        Anschlussstelle = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"ausweichanschlussstelle")]
        Ausweichanschlussstelle = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"bahnhof")]
        Bahnhof = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"bahnhofsgleisgruppe")]
        Bahnhofsgleisgruppe = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"bahnhofsteil")]
        Bahnhofsteil = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"blockstelle")]
        Blockstelle = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"deckungsstelle")]
        Deckungsstelle = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"bahnverwaltungsgrenze")]
        Bahnverwaltungsgrenze = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"regionalbereichsgrenze")]
        Regionalbereichsgrenze = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"haltestelle")]
        Haltestelle = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"haltepunkt")]
        Haltepunkt = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"selbsttaetige_blockstelle")]
        Selbsttaetige_blockstelle = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"ueberleitstelle")]
        Ueberleitstelle = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"unbekannt")]
        Unbekannt = 15,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Routen_typ
    {

        [System.Runtime.Serialization.EnumMember(Value = @"kuerzeste")]
        Kuerzeste = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"schnellste")]
        Schnellste = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"sparsamste")]
        Sparsamste = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"gewichtete")]
        Gewichtete = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Route_maximalwerteStreckenklasse
    {

        [System.Runtime.Serialization.EnumMember(Value = @"D4")]
        D4 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"D3")]
        D3 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"D2")]
        D2 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CM4")]
        CM4 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"CM3")]
        CM3 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"CM2")]
        CM2 = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"CE")]
        CE = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"C4")]
        C4 = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"C3")]
        C3 = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"C2")]
        C2 = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"B2")]
        B2 = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"B1")]
        B1 = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"A")]
        A = 12,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Route_zusammenfassungMarktsegment
    {

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_standard")]
        Sgv_standard = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_sehr_schwer")]
        Sgv_sehr_schwer = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_gefahrgutganzzug")]
        Sgv_gefahrgutganzzug = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_nahverkehr")]
        Sgv_nahverkehr = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_lokfahrt")]
        Sgv_lokfahrt = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_metro_tag_basic_nacht")]
        Spfv_metro_tag_basic_nacht = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_charter_nostalgie")]
        Spfv_charter_nostalgie = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_punkt_zu_punkt")]
        Spfv_punkt_zu_punkt = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_lok_leerfahrt")]
        Spfv_lok_leerfahrt = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"spnv_lastfahrt")]
        Spnv_lastfahrt = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"spnv_lok_leerfahrt")]
        Spnv_lok_leerfahrt = 10,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RoutenpunktHaltart
    {

        [System.Runtime.Serialization.EnumMember(Value = @"durchfahrt")]
        Durchfahrt = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"kundenhalt")]
        Kundenhalt = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"betriebshalt")]
        Betriebshalt = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RoutenpunktHalteplatz_sprungart
    {

        [System.Runtime.Serialization.EnumMember(Value = @"durchbindung")]
        Durchbindung = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"kopfmachen")]
        Kopfmachen = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"rangierfahrt")]
        Rangierfahrt = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Marktsegmente
    {

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_standard")]
        Sgv_standard = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_sehr_schwer")]
        Sgv_sehr_schwer = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_gefahrgutganzzug")]
        Sgv_gefahrgutganzzug = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_nahverkehr")]
        Sgv_nahverkehr = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_lokfahrt")]
        Sgv_lokfahrt = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_metro_tag")]
        Spfv_metro_tag = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_basic")]
        Spfv_basic = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_nacht")]
        Spfv_nacht = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_lok_leerfahrt")]
        Spfv_lok_leerfahrt = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_charter_nostalgie")]
        Spfv_charter_nostalgie = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_punkt_zu_punkt")]
        Spfv_punkt_zu_punkt = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"spnv_lastfahrt")]
        Spnv_lastfahrt = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"spnv_lok_leerfahrt")]
        Spnv_lok_leerfahrt = 12,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RoutenpunktSchiebelok_kupplungsart
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ansetzen")]
        Ansetzen = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"absetzen")]
        Absetzen = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"nachgeschoben_ungekuppelt")]
        Nachgeschoben_ungekuppelt = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"nachgeschoben_gekuppelt")]
        Nachgeschoben_gekuppelt = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"nichts")]
        Nichts = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SucheinstellungenVerkehrsart
    {

        [System.Runtime.Serialization.EnumMember(Value = @"sgv")]
        Sgv = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"lz")]
        Lz = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_lok")]
        Spfv_lok = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_tw")]
        Spfv_tw = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"spnv_lok")]
        Spnv_lok = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"spnv_tw")]
        Spnv_tw = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"sbahn")]
        Sbahn = 6,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SucheinstellungenZeitvorgabe_typ
    {

        [System.Runtime.Serialization.EnumMember(Value = @"abzeit")]
        Abzeit = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"anzeit")]
        Anzeit = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Trassenentgelt_parameterFlexibilitaet
    {

        [System.Runtime.Serialization.EnumMember(Value = @"r_flex")]
        R_flex = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"z_flex")]
        Z_flex = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"kein_flex")]
        Kein_flex = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Trassenentgelt_parameterMarktsegment
    {

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_standard")]
        Sgv_standard = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_sehr_schwer")]
        Sgv_sehr_schwer = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_gefahrgutganzzug")]
        Sgv_gefahrgutganzzug = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_nahverkehr")]
        Sgv_nahverkehr = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"sgv_lokfahrt")]
        Sgv_lokfahrt = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_metro_tag_basic_nacht")]
        Spfv_metro_tag_basic_nacht = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_charter_nostalgie")]
        Spfv_charter_nostalgie = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_punkt_zu_punkt")]
        Spfv_punkt_zu_punkt = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"spfv_lok_leerfahrt")]
        Spfv_lok_leerfahrt = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"spnv_lastfahrt")]
        Spnv_lastfahrt = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"spnv_lok_leerfahrt")]
        Spnv_lok_leerfahrt = 10,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Trassenentgelt_parameterPrioritaet
    {

        [System.Runtime.Serialization.EnumMember(Value = @"express")]
        Express = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"schnell")]
        Schnell = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"keine_prioritaet")]
        Keine_prioritaet = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TriebfahrzeugKennung
    {

        [System.Runtime.Serialization.EnumMember(Value = @"N")]
        N = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"U")]
        U = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"L")]
        L = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Triebfahrzeug_keyKennung
    {

        [System.Runtime.Serialization.EnumMember(Value = @"N")]
        N = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"U")]
        U = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"L")]
        L = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum UrsachenMax_streckenklasse
    {

        [System.Runtime.Serialization.EnumMember(Value = @"D4")]
        D4 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"D3")]
        D3 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"D2")]
        D2 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CM4")]
        CM4 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"CM3")]
        CM3 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"CM2")]
        CM2 = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"CE")]
        CE = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"C4")]
        C4 = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"C3")]
        C3 = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"C2")]
        C2 = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"B2")]
        B2 = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"B1")]
        B1 = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"A")]
        A = 12,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ZugbeeinflussungEtcs_system_version
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ohne")]
        Ohne = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"v1_X")]
        V1_X = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"v2_0")]
        V2_0 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"v2_1")]
        V2_1 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"v2_2")]
        V2_2 = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ZugcharakteristikBremsstellung
    {

        [System.Runtime.Serialization.EnumMember(Value = @"G")]
        G = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"P")]
        P = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"R")]
        R = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"R+Mg")]
        R_Mg = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"R+WB")]
        R_WB = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Dla_u_profile
    {

        [System.Runtime.Serialization.EnumMember(Value = @"P1900")]
        P1900 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"P1901")]
        P1901 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"P1902")]
        P1902 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"P1903")]
        P1903 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"P1904")]
        P1904 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"P1800")]
        P1800 = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"P1801")]
        P1801 = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"P1802")]
        P1802 = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"P1803")]
        P1803 = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"P1804")]
        P1804 = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"P1700")]
        P1700 = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"P1701")]
        P1701 = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"P1702")]
        P1702 = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"P1703")]
        P1703 = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"P1704")]
        P1704 = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"P1602")]
        P1602 = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"P1603")]
        P1603 = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"P1605")]
        P1605 = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"P1606")]
        P1606 = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"P1607")]
        P1607 = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"P1608")]
        P1608 = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"P1609")]
        P1609 = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"P1501")]
        P1501 = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"P1505")]
        P1505 = 23,

        [System.Runtime.Serialization.EnumMember(Value = @"P1506")]
        P1506 = 24,

        [System.Runtime.Serialization.EnumMember(Value = @"P1507")]
        P1507 = 25,

        [System.Runtime.Serialization.EnumMember(Value = @"P1400")]
        P1400 = 26,

        [System.Runtime.Serialization.EnumMember(Value = @"P1405")]
        P1405 = 27,

        [System.Runtime.Serialization.EnumMember(Value = @"P1306")]
        P1306 = 28,

        [System.Runtime.Serialization.EnumMember(Value = @"P1307")]
        P1307 = 29,

        [System.Runtime.Serialization.EnumMember(Value = @"P1308")]
        P1308 = 30,

        [System.Runtime.Serialization.EnumMember(Value = @"P1309")]
        P1309 = 31,

        [System.Runtime.Serialization.EnumMember(Value = @"P1206")]
        P1206 = 32,

        [System.Runtime.Serialization.EnumMember(Value = @"P1207")]
        P1207 = 33,

        [System.Runtime.Serialization.EnumMember(Value = @"P1208")]
        P1208 = 34,

        [System.Runtime.Serialization.EnumMember(Value = @"P1209")]
        P1209 = 35,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ZugcharakteristikFuehrendes_fahrzeug
    {

        [System.Runtime.Serialization.EnumMember(Value = @"lokomotive")]
        Lokomotive = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"steuerwagen")]
        Steuerwagen = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"triebwagen")]
        Triebwagen = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ZugcharakteristikKupplungsbauart
    {

        [System.Runtime.Serialization.EnumMember(Value = @"andere")]
        Andere = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"kn450")]
        Kn450 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"kn500")]
        Kn500 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"kn850")]
        Kn850 = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ZugcharakteristikNachschiebeart
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ohne")]
        Ohne = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ungekuppelt")]
        Ungekuppelt = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ungekuppelt_mit_unbegrenzter_druckkraft")]
        Ungekuppelt_mit_unbegrenzter_druckkraft = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"gekuppelt")]
        Gekuppelt = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"gekuppelt_mit_unbegrenzter_druckkraft")]
        Gekuppelt_mit_unbegrenzter_druckkraft = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ZugcharakteristikStreckenklasse
    {

        [System.Runtime.Serialization.EnumMember(Value = @"D4")]
        D4 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"D3")]
        D3 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"D2")]
        D2 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CM4")]
        CM4 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"CM3")]
        CM3 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"CM2")]
        CM2 = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"CE")]
        CE = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"C4")]
        C4 = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"C3")]
        C3 = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"C2")]
        C2 = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"B2")]
        B2 = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"B1")]
        B1 = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"A")]
        A = 12,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ZugcharakteristikVorspannart
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ohne")]
        Ohne = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"vorspann_mit_gleicher_tfz_baureihe")]
        Vorspann_mit_gleicher_tfz_baureihe = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"vorspann_mit_abweichender_tfz_baureihe")]
        Vorspann_mit_abweichender_tfz_baureihe = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"doppeltraktion_mit_gleicher_tfz_baureihe")]
        Doppeltraktion_mit_gleicher_tfz_baureihe = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"doppeltraktion_mit_abweichender_tfz_baureihe")]
        Doppeltraktion_mit_abweichender_tfz_baureihe = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    internal class DateFormatConverter : Newtonsoft.Json.Converters.IsoDateTimeConverter
    {
        public DateFormatConverter()
        {
            DateTimeFormat = "yyyy-MM-dd";
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client;
        private System.IDisposable _response;

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode;
            Headers = headers;
            Stream = stream;
            _client = client;
            _response = response;
        }

        public void Dispose()
        {
            Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }


    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765